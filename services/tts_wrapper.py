import asyncio
import sys
import json
import os
import edge_tts

async def generate_voice(text, output_file, voice="en-US-GuyNeural"):
    """Generates voice and subtitles using edge_tts Python API."""
    communicate = edge_tts.Communicate(text, voice)
    submaker = edge_tts.SubMaker()
    
    with open(output_file, "wb") as file:
        async for chunk in communicate.stream():
            if chunk["type"] == "audio":
                file.write(chunk["data"])
            elif chunk["type"] == "WordBoundary":
                submaker.feed(chunk)

    # Generate subtitles (SRT)
    srt_file = output_file.replace(".mp3", ".srt")
    with open(srt_file, "w", encoding="utf-8") as f:
        f.write(submaker.get_srt())
        
    return srt_file

def parse_srt_to_json(srt_file):
    """Parses SRT to word-level JSON (using WordBoundary events if available)."""
    # Just reuse existing logic or improve? 
    # Actually, edge-tts WordBoundary gives specific timings. 
    # But let's stick to the previous SRT parser structure for compatibility with moviepy logic
    # or better, parse the SRT file generated by SubMaker.
    
    # Simple SRT parser reuse
    if not os.path.exists(srt_file): return []
    try:
        import re
        with open(srt_file, "r", encoding="utf-8") as f: content = f.read()
        entries = []
        blocks = content.strip().split("\n\n")
        for block in blocks:
            lines = block.split("\n")
            if len(lines) >= 3:
                times = re.findall(r"(\d+:\d+:\d+,\d+)", lines[1])
                if len(times) == 2:
                    start = times[0].replace(",", ".")
                    end = times[1].replace(",", ".")
                    def to_sec(s):
                        h, m, s = s.split(":")
                        return int(h)*3600 + int(m)*60 + float(s)
                    st = to_sec(start)
                    en = to_sec(end)
                    txt = " ".join(lines[2:])
                    # Split logic... actually, using WordBoundary we might get one word per block or sentence.
                    # If sentence, split.
                    words = txt.split()
                    if words:
                        dur = (en - st) / len(words)
                        for i, w in enumerate(words):
                            entries.append({"start": st + i*dur, "end": st + (i+1)*dur, "word": w})
        return entries
    except Exception as e:
        print(f"Error parsing SRT: {e}")
        return []

async def main():
    if len(sys.argv) < 3:
        print("Usage: python tts_wrapper.py <text> <output_file>")
        sys.exit(1)

    text = sys.argv[1]
    output_file = sys.argv[2]
    sub_file = output_file.replace(".mp3", ".json")
    
    voices = ["en-US-GuyNeural", "en-US-AriaNeural", "en-GB-RyanNeural"]
    success = False

    for voice in voices:
        print(f"Trying voice: {voice}")
        try:
            await generate_voice(text, output_file, voice)
            
            # Parse SRT to JSON
            srt_file = output_file.replace(".mp3", ".srt")
            word_data = parse_srt_to_json(srt_file)
            with open(sub_file, "w", encoding="utf-8") as f:
                json.dump(word_data, f)
                
            print(f"Success with {voice}")
            success = True
            break
        except Exception as e:
            print(f"Failed with {voice}: {e}")

    if not success:
        print("All Edge voices failed. Falling back to gTTS...")
        from gtts import gTTS
        try:
            tts = gTTS(text=text, lang='en', tld='co.uk', slow=False)
            tts.save(output_file)
            with open(sub_file, "w") as f: json.dump([], f)
        except Exception as e:
            print(f"gTTS also failed: {e}")
            sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
